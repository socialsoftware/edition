const t=t=>{const e=localStorage.getItem(t);return e?JSON.parse(e):e},e=(t,e)=>Array.from(e).reduce(((e,s)=>(Object.keys(t).includes(s)&&(e[s]=t[s]),e)),{}),s=(t,s)=>{let r=localStorage.getItem(t);if(r)return e(JSON.parse(r),s)},r=(t,e)=>localStorage.setItem(t,JSON.stringify(e)),i=(e,s)=>{let i=t(e);i=i||{},Object.entries(s).forEach((([t,e])=>i[t]=e)),(t=>{localStorage.removeItem(t)})(e),r(e,i)},a=(t,e)=>{const s=(t,e)=>r(t)&&r(e),r=t=>t&&"object"==typeof t;return!(!s(t,e)||Object.values(t).length!==Object?.values(e).length)&&Object.entries(t).every((([t,r],i)=>{const[o,c]=Object.entries(e)[i];return s(r,c)?((t,e)=>t===e)(t,o)&&a(r,c):t===o&&r===c}))};class o{#t;#e;#s;#r;constructor(t,{storageName:r,keys:a}={}){if(this.#r="object"==typeof t?t:t?{state:t}:{},this.#t=new Map,this.#s=new Set,this.#e=void 0,r&&a){this.#e={storageName:r,keys:a};const t=s(r,a);t?this.setState(t,!0):i(r,e(this.#r,a))}}subscribe(t,e){return e?(this.#t.has(e)?this.#t.get(e).add(t):this.#t.set(e,new Set([t])),()=>this.#t.get(e).delete(t)):this.subscribeAll(t)}subscribeAll(t){return this.#s.add(t),()=>this.#s.delete(t)}destroy(){this.#t.clear(),this.#s.clear()}getState(t){return t?this.#r[t]:this.#r}setState(t,s){if(!t)return;t=function(t){return t="object"==typeof t||"function"==typeof t?t:{state:t},t}(t);const r=this.setNextStateAccordingType(t);if(!a(r,this.#r)){const t=this.#r;this.#r=s?r:{...this.#r,...r},this.#e?.storageName&&this.#e?.keys&&i(this.#e.storageName,e(this.#r,this.#e.keys)),Object.keys(r).forEach((e=>{this.#t.get(e)?.forEach((s=>s(this.#r[e],t[e])))})),this.#s.forEach((e=>e(this.#r,t)))}}setNextStateAccordingType(t){return"function"==typeof t?(()=>t(this.#r)||this.#r)():t}}export{o as Store,e as filterObjectByKeys,t as getLocalStorageState,s as getPartialStorage,a as objectsAreEqual,r as setLocalStorageState,i as setPartialStorage};
